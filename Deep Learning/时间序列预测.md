# 1.时间序列
## 1.1 定义
时间序列是一组按时间发生先后顺序进行排列的数据点序列。通常一组时间序列的时间间隔为一恒定值（如1秒，5分钟，12小时，7天，1年），因此时间序列可以作为离散时间数据进行分析处理。

定义应该很好理解，日常生活中时间序列无处不在：CPU负载、上证指数、商场每天的人流量、商品每日价格。
## 1.2 基本任务（预测、异常检测等）
**单指标时序预测任务**：给定某一个指标的历史变化情况，预测其在未来一段时间内的变化。
**多指标时序预测任务**：给定某几个指标的历史变化情况，预测其在未来一段时间内的变化。该任务与单指标时序预测任务的区别在于，几个指标之间不一定相互独立，而是存在某种影响。

**时序异常检测任务**：从正常的时间序列中识别不正常的事件或行为的过程。可以从历史数据中检测，也可以基于时序预测对尚未发生的异常做出预警。

**时序指标聚类**：将变化趋势类似的时序指标归至同一类别。在实际运维工作中，面对的指标可能成百上千，分别对其进行分析，工作量太大，可以在聚类的基础上再做建模分析。

**指标关联分析**：即分析指标A是否会对指标B有影响，以及有什么样的影响（正向/负向、先后关系、多少时间步后造成影响等等）。

# 2.平稳性

## 2.1概念

平稳性是时序分析的重要概念，时序分析基本上是以平稳时间序列为基础的。
平稳性包括弱平稳与强平稳，其中强平稳的证明很困难。好消息是我们一般不需要关注强平稳，常见的时序分析任务都是基于弱平稳做的。

什么是**弱平稳**呢？简单来说需要满足以下三点：
- 均值（即从t=0到当前时间步的均值）为常数
- 方差收敛
- 协方差仅与时间间隔有关，与位置无关。
> [![45I7Q0.png](https://z3.ax1x.com/2021/09/29/45I7Q0.png)](https://imgtu.com/i/45I7Q0)
[![45onSI.png](https://z3.ax1x.com/2021/09/29/45onSI.png)](https://imgtu.com/i/45onSI)

## 2.2 检验方法（ACF、PACF、假设检验）
常用平稳性检验方法有两种。一种是ACF、PACF图，另一种是假设检验。
### 2.1.1 ACF、PACF
ACF指自相关性系数，通常用 R<sub>k</sub> 表示，用于测量时间序列滞后值之间的线性关系，公式如下 ![公式](https://pic2.zhimg.com/80/v2-7cfd4f1540eec5ced1c6a9d8c4e2cd15_720w.jpg) 

PACF指偏自相关性系数，指剔除了中间k-1个随机变量的影响后，x<sub>t-k</sub>对 x<sub>t</sub>影响的相关度量。计算较为复杂，这里不介绍了（其实我也没仔细看）。

以时序预测任务中常见的航班数据集为例，绘图如下：
![](https://pic1.zhimg.com/80/v2-e30c6ccc4237527d06ca3700a30b85f8_720w.jpg)

该数据集的自相关函数ACF与偏自相关函数PACF的示意图如下所示，其中横坐标表示间隔为lag=k
，纵坐标表示r<sub>k</sub>

​![](https://pic4.zhimg.com/80/v2-7694683a68bae3189010fb511f29cd27_720w.jpg)
至此关于ACF、PACF的概念介绍结束，那么它们如何作用于**平稳性检验**呢？对于一个平稳时间序列，自相关系数（ACF）会快速的下降到接近 0 的水平，然而非平稳时间序列的自相关系数会下降的比较缓慢；同样的，非平稳时间序列的自相关系数通常非常大并且为正值。据此，上图中的航班数据集是非平稳的。

我们再举个例子，下图来自于谷歌股价数据集。左图：非平稳；右图：平稳。
![](https://pic4.zhimg.com/v2-c023c401aefa7001e44baa2a12ebd9cf_r.jpg)

### 2.1.2 假设检验
常用的用于检测平稳性的假设检验是**ADF（Augmented Dickey-Fuller Test）**检验，p值小于0.05便可以认为平稳。航班数据集的检验结果如下：
![](https://pic3.zhimg.com/80/v2-337b47fd11b45791531ee8fbb8d63096_720w.jpg)

# 2.3 平稳性转换方法
给定一个非平稳的时间序列，一般需要将它转换为平稳序列，再做建模。常用的平稳性转换方法如下：

- 变形（log函数等）
- 减去移动平均、指数平均等
- 差分

这里要重点说一下差分。所谓差分，就是用 xt-xt-1的值代替 xt，这是一阶差分。在一阶差分的基础上，继续做差分，就是二阶差分。对于大部分时序数据来说，二阶差分后，都可以得到平稳序列，很少用到更高阶的差分。
![](https://pic2.zhimg.com/v2-400d502f0aa113cbc1905084a9440b1d_b.jpg)

值得一提的是，对于很多时序预测模型尤其是深度学习模型来说，我们会发现，代码中可能并没有平稳性转换这一步。这是因为这些模型中往往有自动特征提取的步骤，从而隐性地完成平稳性转换。
**因此，差分的作用是减轻数据之间的不规律波动，使其波动曲线更平稳**

# 2.4 白噪声
- “白噪声”是一个对所有时间其自相关系数为零的随机过程，如果时序数据是白噪声的话，是没有预测意义的。
- 白噪声和残差完全是两个概念，不要混淆。“残差”在数理统计中是指实际观察值与估计值（拟合值）之间的差。
- 时间序列分解时，残差应该为白噪声才合理。如果不是白噪声，可以考虑对残差继续进行时序建模。时间序列分解会在本系列的下一篇文章中介绍。
- 白噪声是平稳的，但是随机游走（或纯随机序列）并非平稳。“随机游走”指基于过去的表现，无法预测将来的发展步骤和方向。
- 平稳的序列并不一定是白噪声。
- Box-Pierce检验（升级版：Ljung-Box检验）用于判断时间序列是否为白噪声。

# 3.时间序列预测
## 3.1 概念
时间序列预测，指将时间序列分解为三部分：趋势项，季节项，残差项。

一般包括**乘性分解与加性分解**，前者即时间序列=趋势项*季节项*残差项，后者即时间序列=趋势项+季节项+残差项。
对于乘法性模型，可以取对数，将其转化为加法性模型。
如果季节性波动的幅度或者趋势周期项的波动不随时间序列水平的变化而变化，那么加法模型是最为合适的。当季节项或趋势周期项的变化与时间序列的水平成比例时，则乘法模型更为合适。例如，在经济时间序列中，乘法模型较为常用。

注意季节性不一定指每季，也可以指每年/月/周等。

中心移动平均是提取季节项的基础方法。
## 3.2 常见分解方法
## 3.2.1 经典分解法
经典算法步骤相对简单，在没有计算机和计算机算力不强的年代很是实用，同时它也是很多其他分解算法的基础。经典分解法假设周期性成分在每个周期内都是相同的（如每年的月周期成分都相同）。经典分解法使用移动平均法处理数据。

首先估计周期长度，以一周期为区间，对一块块数据取均值，得出趋势。然后使用原数据减去趋势，求不同块数据的均值，得出周期序列，而后根据该二者得出残差。乘法性模型的求解方法类似。

# 3.2.2 X11分解法
X11方法基于经典分解法，包括很多其它的步骤和特点来克服经典分解法的一些不足。X11有一些复杂的方法来处理交易日、假期及一些其它已知的影响因素的影响。它能够处理加法性模型和乘法性模型。该方法鲁棒性强，能够处理时间序列中的异常值和数据突变。
![](https://pic2.zhimg.com/80/v2-b0a040f4fc766709e9c4b313d7a70bf5_720w.jpg)

# 3.2.3 SEATS分解法

“SEATS”全称“Seasonal Extraction in ARIMA Time Series”，也称X-13-ARIMA-SEATS方法。此方法由西班牙银行开发。这个算法只是针对季度性和月度数据。因此天级数据、小时级数据或者周数据，需要其他的方法。

Python内有X13库，但并不对外提供分解接口。

# 3.2.4 STL分解法

STL是一种多功能、鲁棒的方法。全称“Seasonal and Trend decomposition using Loess”，其中Loess是一种鲁棒的回归算法。

特点：

与SEATS与X11不同，STL可以处理任意季节性数据，而非局限于月度或季度数据
季节部分可以随时间变化，变化率可以由用户控制。STL的一大特点便是提供对季节性的单独乘法趋势，可以在采用加法型模型时，使加上去的趋势的幅度不断扩大。且该变化率是自动检测的。
趋势周期的平滑度可以由用户控制
可以对异常值鲁棒（使异常值不影响季节部分与趋势部分，但是影响残差），代码中一般有robust=True/False控制。
缺点：

不能自动处理节假日
不支持乘性分解（可以通过log、box-cox变换实现）

# 3.2.5 fbprophet分解

由Facebook的fbprophet库提供的分解接口，具体原理未知，资料显示其类似于STL算法，可以设定多个独立运作的周期，可以指定节假日，可以和STL一样设定周期的乘法性，指定诸多参数。功能全面且强大，性能也强于STL。主要缺陷有：同STL一样不提供乘法性分解（可以使用log处理达到效果），且似乎没有提供独立的分解序列的方法，只能训练完模型后查看分解结果，因此难以将其当做独立的分解方法用于其它预测方法。

# 4.ARIMA模型
最重要的**时序预测模型**。在任何一篇关于时序预测的介绍中，都能看到这个模型的身影。

ARIMA模型本质上由三部分组成，**AR（p阶自回归模型）+I（i阶差分）+MA（q阶移动平均模型）**。
[![4IuJLn.png](https://z3.ax1x.com/2021/09/30/4IuJLn.png)](https://imgtu.com/i/4IuJLn)
- 自回归模型的限制
    - 自回归模型是用自身的数据进行预测
    - 必须具有平稳性
    - 必须具有自相关性，如果自相关系数小于0.5，则不宜采用
    - 自回归只适用于预测与自身前期相关的想象

[![4Iugdx.png](https://z3.ax1x.com/2021/09/30/4Iugdx.png)](https://imgtu.com/i/4Iugdx)
[![4IuxSg.png](https://z3.ax1x.com/2021/09/30/4IuxSg.png)](https://imgtu.com/i/4IuxSg)
[![4IK4A0.png](https://z3.ax1x.com/2021/09/30/4IK4A0.png)](https://imgtu.com/i/4IK4A0)
ARIMA首先要确定差分阶数i，以确保数据在i阶差分后平稳；接着，再确定是AR（q=0）、MA（p=0）还是ARMA（p、q均不为0）。

参数p、q可以通过ACF图与PACF图选定。但是在学习过程中，我发现许多文章关于p、q的选定方法有自相矛盾之处，且这种方法多基于感性认识（如拖尾/截尾、快速下降、明显突起的判断等），不够精确。再次不再详细介绍这方面的内容。实际工程中，一般会通过网格搜索的方式确定p、i、q的最优取值，一般以AIC/BIC信息准则作为变量的选择依据。

# 5.Holt模型
对于没有明显趋势或季节因素的数据，可以使用“简单指数平滑”(一次指数平滑，或一阶holt)，直观理解就是离当前时间步越近的历史值，影响越大：
在实际使用中，一般都会用Holt-Winter。python中的statsmodels.tsa库提供了holt模型。

再次总结一下ARIMA与Holt的联系：

一阶Holt—Winters假设数据是stationary的（静态分布）
二阶Holt假设数据有一个趋势
三阶Holt在二阶的假设基础上，多了一个周期性的成分。
AR/MA/ARMA假设数据是平稳的
ARIMA假设数据是非平稳的，且通过一次/两次差分可以实现平稳（也就是参数中i的含义）
# 6. Prophet模型
分段线性或逻辑增长曲线趋势。 Prophet通过从数据中选择改变点，自动检测趋势的变化。
用傅里叶级数模拟每年的季节性分量。
用虚拟变量来模拟每周的周期性分量。
用户提供的重要节日列表

# 7.**深度学习方法**
# 7.1 LSTM长短期记忆网络
```PYTHON
class LSTM(nn.Module):
    def __init__(self, input_size=1, hidden_layer_size=100, output_size=1):
        super().__init__()
        self.hidden_layer_size = hidden_layer_size

        self.lstm = nn.LSTM(input_size, hidden_layer_size)

        self.linear = nn.Linear(hidden_layer_size, output_size)

        self.hidden_cell = (torch.zeros(1,1,self.hidden_layer_size),
                            torch.zeros(1,1,self.hidden_layer_size)) # (num_layers * num_directions, batch_size, hidden_size)

    def forward(self, input_seq):
        lstm_out, self.hidden_cell = self.lstm(input_seq.view(len(input_seq) ,1, -1), self.hidden_cell)
        predictions = self.linear(lstm_out.view(len(input_seq), -1))
        return predictions[-1]
```
> 具体代码讲解：D:\GitRepos\Time-Series-Forecast\LSTM

# 7.2 Transformer
本质上该代码使用的是Transformer的encoder部分。
支持多步预测。
输入为1～100时间步，其中最后5个时间步全部替换为0，输出为1～100时间步的真实值。

# 7.3 Informer
首先介绍一个新任务，LSTF（Long Sequence Time-Series Forecasting），即长序列预测任务。刚刚我们提到的LSTM模型，往往以滑动窗口（或动态解码）的形式做长序列预测，随着时间步的增长，预测误差会逐渐放大。

[![4IJkz6.png](https://z3.ax1x.com/2021/09/30/4IJkz6.png)](https://imgtu.com/i/4IJkz6)
