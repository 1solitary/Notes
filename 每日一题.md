# 2020-2021寒假每日一题
## iostream与stdio的区别
```
stdio属于c语言，开发c程序用stdio，输入输出格式为printf()，scanf()
iostream属于c++语言，开发c++程序可以用stdio和iostream，推荐使用 iostream，输入输出格式为count<<..，cin>>.
```    

## 由数据范围反推算法复杂度以及算法内容
[![WKmRDU.png](https://z3.ax1x.com/2021/07/16/WKmRDU.png)](https://imgtu.com/i/WKmRDU)

## Day-1（《104. 货仓选址》绝对值不等式）
- 所有点排序，如果点数是奇数选择中位数，偶数选择中间两个数都可以，相加距离最小
```C++
#include <iostream>
#include <algorithm>

using namespace std;

const int N=1e6+10;
int n,a[N];

int main(){
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    sort(a,a+n);
    int res=0;
    for(int i=0;i<n;i++) res+= abs(a[i]-a[n/2]);
    cout<<res<<endl;
    return 0;
}
```
## Day-2（《898. 数字三角形》动态规划）

- 知识点1：从下到上进行考虑，只需要考虑某值是从哪一边上来的，而不用考虑从上至下时会出现越界的问题[![WKnqWn.png](https://z3.ax1x.com/2021/07/16/WKnqWn.png)](https://imgtu.com/i/WKnqWn)
- 闫氏DP分析法：采用集合的思想去解决问题。比如统计成绩，统计每个人的成绩肯定不如统计每个班的成绩来的快。
    - 每个状态表示一个集合
    - 集合存的是哪个属性（最大值，平均值等等）
    - 结果为``f(i+1.j)+w(i,j) 和 f(i+1,j+1)+w(i,j)``之间的最大值
    - 时间复杂度为O(N<sup>2</sup>)
    - 最下面一行的边界值处理：``f(n,i)=w(n,i); ``
[![WKumwD.png](https://z3.ax1x.com/2021/07/16/WKumwD.png)](https://imgtu.com/i/WKumwD)
```C++
#include <iostream>
#include <algorithm>
 
using namespace std;

const int N=510;

int n,f[N][N],w[N][N];

int main(){
    cin>>n;
    for(int i=1; i<=n; i++)
        for(int j=1; j<=i;j++)
            cin>>w[i][j];
    
    for(int j=1;j<=n;j++)  f[n][j]=w[n][j];
    for(int i= n-1;i>0;i--)
        for(int j=1;j<=i;j++)
            f[i][j] = w[i][j]+max(f[i+1][j],f[i+1][j+1]);
    cout<<f[1][1]<<endl;
}
```

## Day-3（《 756. 蛇形矩阵》偏移量技巧）
- 设置偏移量数组
[![WK0Hkd.png](https://z3.ax1x.com/2021/07/16/WK0Hkd.png)](https://imgtu.com/i/WK0Hkd)
```C++
    int dx[] ={-1,0,1,0},int dy[]={0,1,0,-1};
    for(int i=0;i<4;i++){
        a=x+dx[i], b=y+dy[i];
    }
    if(判断条件){
        //执行语句
    }
```
```c++
#include <iostream>

using namespace std;

const int N = 110;

int n, m;
int q[N][N];

int main()
{
    cin >> n >> m;
    int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
    int x = 0, y = 0, d = 1;
    for (int i = 1; i <= n * m; i ++ )
    {
        q[x][y] = i;
        int a = x + dx[d], b = y + dy[d];
        if (a < 0 || a >= n || b < 0 || b >= m || q[a][b])
        {
            d = (d + 1) % 4;
            a = x + dx[d], b = y + dy[d];
        }
        x = a, y = b;
    }

    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
            cout << q[i][j] << ' ';
        cout << endl;
    }

    return 0;
}
```
## Day-4（《1113. 红与黑》Flood Fill算法）
-  ``while(cin>>m>>n,n||m)``
输入m，n当在一行中读入的是两个零时，表示输入结束。
- 
    ``#define x first``
   `` #define y second``
定义二维数组的两个值
- ``typedef pair<int,int> Pii;``使用二维数组
``queue<Pii> que;``快速定义队列中的元素为二维数组
``que.push({x,y});``元素压入队列中
- ``for (int i = 0; i < n; i ++ ) cin >> g[i];``
快速输入二维数组，作用相当于下面的代码
    ```
    for (int i = 0; i < n; i ++ )
        for(int j=0;j<m;j++) 
            cin>>g[i][j];
    ```
- ``if(x<0 || x>n|| y<0 || y>m || g[x][y]!='.') continue;``
找到下一个可以满足条件的格子。
在循环体中的语句集合执行中，continue语句用于结束本次循环。
 ```c++
#include <iostream>
#include <algorithm>
#include <queue>

#define x first
#define y second

using namespace std;

typedef pair<int,int> pii;
queue <pii> q;

const int N=25;
int n,m;
char f[N][N];

int bfs(int sx,int sy){
    q.push({sx,sy});
    
    f[sx][sy]='#';
    int res=0;
    int dx[]={-1,0,1,0},dy[]={0,1,0,-1};
    
    while(q.size()){
        auto t =q.front();
        
        q.pop();
        res++;
        
        for(int i=0;i<4;i++){
            int x=t.x+dx[i],y=t.y+dy[i];
            if(x<0 || x>=n || y<0 || y>=m || f[x][y]!='.') continue;
            f[x][y]='#';
            q.push({x,y});
        }
    }
    return res;
}
int main(){
    while(cin>>m>>n,n||m){
        for(int i=0;i<n;i++) cin >> f[i];
        
        int x,y;
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
                if(f[i][j]=='@')
                    x=i,y=j;
        
       cout << bfs(x, y) << endl;
    }
    return 0;
}
```

## Day-5（《1346. 回文平方》进位制）
- 将10进制转为b进制
	短除法
    [![WsIqhQ.png](https://z3.ax1x.com/2021/07/23/WsIqhQ.png)](https://imgtu.com/i/WsIqhQ)
    ```c++
    char get(int n){
    if(n<=9) return n+'0';
    else return n-10+'A';
    }

    string base(int n,int b){
        string num;
        while(n){
            num+=get(n%b),n/=b;
        }
        reverse(num.begin(),num.end());
        return num;
    }
    ```

- 判断是否为回文数
    ```C++

    bool check(string num){
        for(int i=0,j=num.size()-1;i<j;i++,j--){
                if(num[i]!=num[j]) return false;
            }
            return true;
    }
    ```
## Day-6（《680. 剪绳子》浮点数二分）
```C++

#include <iostream>
#include <cstdio>

using namespace std;

const int N=1e6+10;
int n,m;
int q[N];

bool check(double x){
    int res=0;
    for(int i=0;i<n;i++){
        res+=q[i]/x;
   
    }
    return res>=m;
}
int main(){
    cin>>n>>m;
    
    
    for(int i=0;i<n;i++){
        cin>>q[i];
    }
    
    double l=0,r=1e9;
    while(r-l>1e-4){
        double mid=(r+l)/2;
        if(check(mid)) l=mid;
        else r=mid;
    }
    printf("%.2lf\n",r);
    return 0;
}
```
- 答案要求保留两位小数 ``printf("%.2lf\n",r);``
- 浮点数二分的循环判定 ``r-l>1e-4``。答案要求2位小数，判定条件位1e^-(2+2)
## Day-7（《1227. 分巧克力》整数二分）
