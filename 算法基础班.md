# 快速排序
- 思想：分治
    - 确定分界点：``q[l],q[(l+r)/2],q[r],随机``
    -  调整范围 ：使得第一个区间的值都小于等于x，第二个区间的值都大于等于x（重点）
    -  递归处理左右两端
- 做法
```c++
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int n;
int q[N];

void quick_sort(int q[], int l, int r) {
    if(l >= r) return;
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while(i < j) {
        while(q[++i] < x);
        while(q[--j] > x);
        if(i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}

int main() {
    scanf("%d", &n);
    for(int i = 0; i < n; i++) scanf("%d", &q[i]);
    quick_sort(q, 0, n-1);
    for(int i = 0; i < n; i++) printf("%d ", q[i]);
    return 0;
}
```
- 分界点处理问题
    ```
    1.
     int x = q[l+r>>1];
     quick_sort(q,l,j);
     quick_sort(q,j+1,r);
     ```
     
     ```
     2.
      int x = q[l+r+1>>1];
      quick_sort(q,l,i-1);
      quick_sort(q,1,r);
     ```
- 当题目数据加强时，尽量选择数据中点
输入数据为1，2时，可以自行判断一下。
[![WpAjyQ.png](https://z3.ax1x.com/2021/07/10/WpAjyQ.png)](https://imgtu.com/i/WpAjyQ)
***
# 归并算法
 - 确定分界点 mid=(l+r)/2
 - 递归排序left，right
 - 归并：合二为一
 [![WpEGOH.png](https://z3.ax1x.com/2021/07/10/WpEGOH.png)](https://imgtu.com/i/WpEGOH)
 
 ```c++
 #include <iostream>

using namespace std;
const int N=1000010;
int n;
int q[N],temp[N];

void mergersort(int l,int r){
    if(l>=r) return;
    int mid = l+r>>1;
    mergersort(l,mid),mergersort(mid+1,r);
    
    int k=0,i=l,j=mid+1;
    while(i<=mid&&j<=r){
        if(q[i]<=q[j]) temp[k++]=q[i++];
        else temp[k++]=q[j++];
    }
    while(i<=mid) temp[k++]=q[i++];
    while(j<=r) temp[k++]=q[j++];
    
    for(i=l,j=0;i<=r;i++,j++) q[i]=temp[j];
}

int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d",&q[i]);
    }
    mergersort(0,n-1);
    for(int i=0;i<n;i++)
        printf("%d ",q[i]);
        
    return 0;
}
```

***

# 二分模板（解决边界问题）
## 整数二分
算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。
- 当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。
```c++
 int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```
-  当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。
```c++
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```
 - 先写一个check函数
 - 判定在check的情况下（true和false的情况下），如何更新区间。
 - 在check(m)==true的分支下是:
    - l=mid的情况，中间点的更新方式是m=(l+r+1)/2
    - r=mid的情况，中间点的更新方式是m=(l+r)/2
 - 这种方法保证了：
    1. 最后的``l==r``
    2. 搜索到达的答案是闭区间的，即a[l]是满足check()条件的。
## 浮点数二分
    保留四位小数（1e-6一定要多2）
```c++
#include<iostream>

using namespace std;

double n;

int main(){
    cin >> n;

    double l = -1e4, r = 1e4;
    while(r - l > 1e-8){
        double mid = (l + r) / 2;
        if(mid * mid * mid >= n) r = mid;
        else l = mid;
    }

    printf("%lf", l);

    return 0;
}
```

# 高精度问题
指的是大整数运算，包括加减乘除，这算是算法开发面试中经常能看到的一类问题，实际上就是对我们人工真实加减乘除的简单模拟。
[![Wpl1Ug.png](https://z3.ax1x.com/2021/07/10/Wpl1Ug.png)](https://imgtu.com/i/Wpl1Ug)
- 因为C++中的 一般运算变量类型 例如int、long long 等大小限制，无法完成大数字的运算。
## 高精度加法

- 用数组存储，数组第0位通常存储大数的个位因为进位时，在末尾添加数组比较方便
- 加引用的作用是提高效率，这样就不会重新拷贝一遍数组
```c++
#include<iostream>
#include<vector>
using namespace std;
vector<int> sum(vector<int>& a,vector<int>& b)
{
    vector<int> result;
    if(a.size()<b.size()) return sum(b,a);
    int t=0;//进位
    for(int i=0;i<a.size() || t;i++)//a.size() >= b.size()
    {
        if(i<a.size()) t+=a[i];
        if(i<b.size()) t+=b[i];
        result.push_back(t%10);
        t/=10;//更新进位
    }
    return result;
}
int main()
{
    string a,b;
    vector<int> c,d;
    vector<int> result;//存放结果
    cin>>a>>b;
    //按 个位 十位 百位 ...n位 存放
    for(int i=a.size()-1;i>=0;i--) c.push_back(a[i]-'0');//将字符a[i]转换成数值
    for(int i=b.size()-1;i>=0;i--) d.push_back(b[i]-'0');//将字符b[i]转换成数值
    result=sum(c,d);
    for(int i=result.size()-1;i>=0;i--) cout<<result[i];
    return 0;
}
```
## 高精度减法
### 思路
- 和高精度加法差不多，值得注意的是
    - 减法的借位处理
    - 相减为负数的处理
    [![WpzZY4.png](https://z3.ax1x.com/2021/07/11/WpzZY4.png)](https://imgtu.com/i/WpzZY4)
    - 前导0的处理`` while(C.size() > 1 && C.back() == 0) C.pop_back();  //去掉前导0``去除前导0，123-120=003，实际为300，这样去掉后面的0

### 收获
- 对于 t = A[i] - B[i] - t； 可以拆为 t = A[i] - t如果B[i]合法，再t -= B[i] 这么两步来做
- 相减后t的处理 ，把 t >=0 和 t < 0 用一个式子来表示 t = (t + 10) % 10 这个木有想到
- A B大小判断，自己写的太冗余，不如单独拎出来
```c++
bool cmp(vector<int>& A, vector<int> &B)
{
    if(A.size() != B.size()) return A.size() > B.size();  //直接ruturn 了就不用else

    for(int i = A.size(); i >= 0; i--)
        if(A[i] != B[i])
            return A[i] > B[i];

    return true;
}
```
```c++
#include <iostream>
#include <vector>

using namespace std;

bool cmp(vector<int>& A, vector<int> &B)
{
    if(A.size() != B.size()) return A.size() > B.size();  //直接ruturn 了就不用else

    for(int i = A.size(); i >= 0; i--)
        if(A[i] != B[i])
            return A[i] > B[i];

    return true;
}

vector <int> sub(vector<int>& A, vector<int> &B)
{
    vector<int> C;
    int t = 0;
    for(int i = 0; i < A.size(); i++)
    {
        t = A[i] - t;
        if(i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10 ); // 合而为1
        if(t < 0)  t = 1;
        else t = 0;

    }

    while(C.size() > 1 && C.back() == 0) C.pop_back();  //去掉前导0

    return C;
}

int main()
{
    string a ,b;
    vector<int> A, B;

    cin >> a >> b ;

    for(int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
    for(int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');

    if (cmp(A,B)) 
    {
        auto C = sub(A, B);
        for(int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
        return 0;
    }
    else
    {
        auto C = sub(B, A);
        printf("-");
        for(int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
        return 0;
    }


}


```
## 高精度乘法
[![WPUjUA.png](https://z3.ax1x.com/2021/07/12/WPUjUA.png)](https://imgtu.com/i/WPUjUA)
```c++
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
vector<int> mul(vector<int> &A,int b)
{
    vector<int> C;
    int t=0;
    for(int i=0;i<A.size()||t;i++)
    {
        t+=A[i]*b;
        C.push_back(t%10);
        t/=10;
    }
    if(t) C.push_back(t);
    while(C.size()>1&&C.back()==0)
        C.pop_back(); 
    return C;
}
int main()
{
    string a;
    int b;
    vector<int> A;
    cin>>a>>b;
    for(int i=a.size()-1;i>=0;i--)
        A.push_back(a[i]-'0');
    vector<int> C=mul(A,b);
    for(int i=C.size()-1;i>=0;i--)
        printf("%d",C[i]);
    return 0;
}

```
## 高精度除法
```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
//int r=0;
vector<int> div(vector<int> &A,int B,int &r){//r传入r的地址，便于直接对余数r进行修改
    vector<int> C;
    for(int i=0;i<A.size();i++){//对A从最高位开始处理
        r=r*10+A[i];//将上次的余数*10在加上当前位的数字，便是该位需要除的被除数
        C.push_back(r/B);//所得即为商在这一位的数字
        r=r%B;
    }
    //由于在除法运算中，高位到低位运算，因此C的前导零都在vector的前面而不是尾部，vector只有删除最后一个数字pop_back是常数复杂度，而对于删除第一位没有相应的库函数可以使用，而且删除第一位，其余位也要前移，
    //因此我们将C翻转，这样0就位于数组尾部，可以使用pop函数删除前导0
    reverse(C.begin(),C.end());
    while(C.size()>1&&C.back()==0) C.pop_back();
    return C;
}
int main(){
    string a;
    int B,r=0; //代表余数
    cin>>a>>B;
    vector<int> A;
    for(int i=0;i<a.size();i++) A.push_back(a[i]-'0');//注意这次的A是由高为传输至低位，由于在除法的手算过程中，发现从高位进行处理
    //for(int i=0;i<A.size();i++) cout<<A[i];
    //cout<<B;
    auto C = div(A,B,r);
    for(int i=C.size()-1;i>=0;i--) cout<<C[i];//将C从最高位传给最低位
    cout<<endl<<r;//输出余数
    cout<<endl;
    return 0;
}

```