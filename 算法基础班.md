# 快速排序
- 思想：分治
    - 确定分界点：``q[l],q[(l+r)/2],q[r],随机``
    -  调整范围 ：使得第一个区间的值都小于等于x，第二个区间的值都大于等于x（重点）
    -  递归处理左右两端
- 做法
```c++
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int n;
int q[N];

void quick_sort(int q[], int l, int r) {
    if(l >= r) return;
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while(i < j) {
        while(q[++i] < x);
        while(q[--j] > x);
        if(i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}

int main() {
    scanf("%d", &n);
    for(int i = 0; i < n; i++) scanf("%d", &q[i]);
    quick_sort(q, 0, n-1);
    for(int i = 0; i < n; i++) printf("%d ", q[i]);
    return 0;
}
```
- 分界点处理问题
    ```
    1.
     int x = q[l+r>>1];
     quick_sort(q,l,j);
     quick_sort(q,j+1,r);
     ```
     
     ```
     2.
      int x = q[l+r+1>>1];
      quick_sort(q,l,i-1);
      quick_sort(q,1,r);
     ```
- 当题目数据加强时，尽量选择数据中点
输入数据为1，2时，可以自行判断一下。
[![WpAjyQ.png](https://z3.ax1x.com/2021/07/10/WpAjyQ.png)](https://imgtu.com/i/WpAjyQ)
***
# 归并算法
 - 确定分界点 mid=(l+r)/2
 - 递归排序left，right
 - 归并：合二为一
 [![WpEGOH.png](https://z3.ax1x.com/2021/07/10/WpEGOH.png)](https://imgtu.com/i/WpEGOH)
 
 ```c++
 #include <iostream>

using namespace std;
const int N=1000010;
int n;
int q[N],temp[N];

void mergersort(int l,int r){
    if(l>=r) return;
    int mid = l+r>>1;
    mergersort(l,mid),mergersort(mid+1,r);
    
    int k=0,i=l,j=mid+1;
    while(i<=mid&&j<=r){
        if(q[i]<=q[j]) temp[k++]=q[i++];
        else temp[k++]=q[j++];
    }
    while(i<=mid) temp[k++]=q[i++];
    while(j<=r) temp[k++]=q[j++];
    
    for(i=l,j=0;i<=r;i++,j++) q[i]=temp[j];
}

int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d",&q[i]);
    }
    mergersort(0,n-1);
    for(int i=0;i<n;i++)
        printf("%d ",q[i]);
        
    return 0;
}
```

***

# 二分模板（解决边界问题）
## 整数二分
算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。
- 当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。
```c++
 int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```
-  当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。
```c++
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```
 - 先写一个check函数
 - 判定在check的情况下（true和false的情况下），如何更新区间。
 - 在check(m)==true的分支下是:
    - l=mid的情况，中间点的更新方式是m=(l+r+1)/2
    - r=mid的情况，中间点的更新方式是m=(l+r)/2
 - 这种方法保证了：
    1. 最后的``l==r``
    2. 搜索到达的答案是闭区间的，即a[l]是满足check()条件的。
## 浮点数二分
    保留四位小数（1e-6一定要多2）
```c++
#include<iostream>

using namespace std;

double n;

int main(){
    cin >> n;

    double l = -1e4, r = 1e4;
    while(r - l > 1e-8){
        double mid = (l + r) / 2;
        if(mid * mid * mid >= n) r = mid;
        else l = mid;
    }

    printf("%lf", l);

    return 0;
}
```

# 高精度问题
指的是大整数运算，包括加减乘除，这算是算法开发面试中经常能看到的一类问题，实际上就是对我们人工真实加减乘除的简单模拟。
[![Wpl1Ug.png](https://z3.ax1x.com/2021/07/10/Wpl1Ug.png)](https://imgtu.com/i/Wpl1Ug)
- 因为C++中的 一般运算变量类型 例如int、long long 等大小限制，无法完成大数字的运算。
## 高精度加法

- 用数组存储，数组第0位通常存储大数的个位因为进位时，在末尾添加数组比较方便
- 加引用的作用是提高效率，这样就不会重新拷贝一遍数组
```c++
#include<iostream>
#include<vector>
using namespace std;
vector<int> sum(vector<int>& a,vector<int>& b)
{
    vector<int> result;
    if(a.size()<b.size()) return sum(b,a);
    int t=0;//进位
    for(int i=0;i<a.size() || t;i++)//a.size() >= b.size()
    {
        if(i<a.size()) t+=a[i];
        if(i<b.size()) t+=b[i];
        result.push_back(t%10);
        t/=10;//更新进位
    }
    return result;
}
int main()
{
    string a,b;
    vector<int> c,d;
    vector<int> result;//存放结果
    cin>>a>>b;
    //按 个位 十位 百位 ...n位 存放
    for(int i=a.size()-1;i>=0;i--) c.push_back(a[i]-'0');//将字符a[i]转换成数值
    for(int i=b.size()-1;i>=0;i--) d.push_back(b[i]-'0');//将字符b[i]转换成数值
    result=sum(c,d);
    for(int i=result.size()-1;i>=0;i--) cout<<result[i];
    return 0;
}
```
## 高精度减法
### 思路
- 和高精度加法差不多，值得注意的是
    - 减法的借位处理
    - 相减为负数的处理
    [![WpzZY4.png](https://z3.ax1x.com/2021/07/11/WpzZY4.png)](https://imgtu.com/i/WpzZY4)
    - 前导0的处理`` while(C.size() > 1 && C.back() == 0) C.pop_back();  //去掉前导0``去除前导0，123-120=003，实际为300，这样去掉后面的0

### 收获
- 对于 t = A[i] - B[i] - t； 可以拆为 t = A[i] - t如果B[i]合法，再t -= B[i] 这么两步来做
- 相减后t的处理 ，把 t >=0 和 t < 0 用一个式子来表示 t = (t + 10) % 10 这个木有想到
- A B大小判断，自己写的太冗余，不如单独拎出来
```c++
bool cmp(vector<int>& A, vector<int> &B)
{
    if(A.size() != B.size()) return A.size() > B.size();  //直接ruturn 了就不用else

    for(int i = A.size(); i >= 0; i--)
        if(A[i] != B[i])
            return A[i] > B[i];

    return true;
}
```
```c++
#include <iostream>
#include <vector>

using namespace std;

bool cmp(vector<int>& A, vector<int> &B)
{
    if(A.size() != B.size()) return A.size() > B.size();  //直接ruturn 了就不用else

    for(int i = A.size(); i >= 0; i--)
        if(A[i] != B[i])
            return A[i] > B[i];

    return true;
}

vector <int> sub(vector<int>& A, vector<int> &B)
{
    vector<int> C;
    int t = 0;
    for(int i = 0; i < A.size(); i++)
    {
        t = A[i] - t;
        if(i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10 ); // 合而为1
        if(t < 0)  t = 1;
        else t = 0;

    }

    while(C.size() > 1 && C.back() == 0) C.pop_back();  //去掉前导0

    return C;
}

int main()
{
    string a ,b;
    vector<int> A, B;

    cin >> a >> b ;

    for(int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
    for(int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');

    if (cmp(A,B)) 
    {
        auto C = sub(A, B);
        for(int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
        return 0;
    }
    else
    {
        auto C = sub(B, A);
        printf("-");
        for(int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
        return 0;
    }


}


```
## 高精度乘法
[![WPUjUA.png](https://z3.ax1x.com/2021/07/12/WPUjUA.png)](https://imgtu.com/i/WPUjUA)
```c++
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
vector<int> mul(vector<int> &A,int b)
{
    vector<int> C;
    int t=0;
    for(int i=0;i<A.size()||t;i++)
    {
        t+=A[i]*b;
        C.push_back(t%10);
        t/=10;
    }
    if(t) C.push_back(t);
    while(C.size()>1&&C.back()==0)
        C.pop_back(); 
    return C;
}
int main()
{
    string a;
    int b;
    vector<int> A;
    cin>>a>>b;
    for(int i=a.size()-1;i>=0;i--)
        A.push_back(a[i]-'0');
    vector<int> C=mul(A,b);
    for(int i=C.size()-1;i>=0;i--)
        printf("%d",C[i]);
    return 0;
}

```
## 高精度除法
```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
//int r=0;
vector<int> div(vector<int> &A,int B,int &r){//r传入r的地址，便于直接对余数r进行修改
    vector<int> C;
    for(int i=0;i<A.size();i++){//对A从最高位开始处理
        r=r*10+A[i];//将上次的余数*10在加上当前位的数字，便是该位需要除的被除数
        C.push_back(r/B);//所得即为商在这一位的数字
        r=r%B;
    }
    //由于在除法运算中，高位到低位运算，因此C的前导零都在vector的前面而不是尾部，vector只有删除最后一个数字pop_back是常数复杂度，而对于删除第一位没有相应的库函数可以使用，而且删除第一位，其余位也要前移，
    //因此我们将C翻转，这样0就位于数组尾部，可以使用pop函数删除前导0
    reverse(C.begin(),C.end());
    while(C.size()>1&&C.back()==0) C.pop_back();
    return C;
}
int main(){
    string a;
    int B,r=0; //代表余数
    cin>>a>>B;
    vector<int> A;
    for(int i=0;i<a.size();i++) A.push_back(a[i]-'0');//注意这次的A是由高为传输至低位，由于在除法的手算过程中，发现从高位进行处理
    //for(int i=0;i<A.size();i++) cout<<A[i];
    //cout<<B;
    auto C = div(A,B,r);
    for(int i=C.size()-1;i>=0;i--) cout<<C[i];//将C从最高位传给最低位
    cout<<endl<<r;//输出余数
    cout<<endl;
    return 0;
}

```

# 双指针算法
- 算法模板
```c++
 for（int i=0, j=0; i<n ; i++){
     while(i<j && check(i,j)) j++;
     //每道题的具体逻辑
 }
 - 核心思想：
   for（int i=0; i<n ; i++){
        for（int j=0; j<n ; j++){
                O(N^2)
    运用某些性质
    将上面的朴素算法优化到O(N)

- [原题链接](www.acwing.com/solution/content/2354/)
```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N =1e5;

int n;
int q[N],w[N];

int main(){
    cin>>n;
    int res=0;
    for(int i=0;i<n;i++) cin>>q[i];
    
    for(int i=0,j=0;i<n;i++){
        w[q[i]]++;
        while(w[q[i]]>1){
            w[q[j]]--;
            j++;
        }
        res = max(res,i-j+1);
    }
    cout<<res<<endl;
}
```
# 前缀和
- 作用：可以求特定区间里的和
- [![fYlkaq.png](https://z3.ax1x.com/2021/08/10/fYlkaq.png)](https://imgtu.com/i/fYlkaq)
    S[i]从1开始，S[0]=0可以处理边界问题(c++里面全局变量初始就是0了)
- [原题链接](https://www.acwing.com/solution/content/2075/)
```c++
#include <iostream>

using namespace std;

const int N=1e5+10;

int n,m;
int s[N],a[N];


int main(){
   
        for(int i=1;i<=n;i++) cin>>a[i];
        for(int i=1;i<=n;i++){
            s[i]=s[i-1]+a[i];//前缀和的初始化
        }
        int l,r;
        while(m--){
            cin>>l>>r;
            cout<<s[l]-s[r-1]<<endl;//区间和的计算
            
        }
    return 0;
}
```
## 二维化的前缀和
[![fYwR61.png](https://z3.ax1x.com/2021/08/10/fYwR61.png)](https://imgtu.com/i/fYwR61)
    - S[i,j]S[i,j]即为图1红框中所有数的的和为：
        ``S[i,j]=S[i,j−1]+S[i−1,j]−S[i−1,j−1]+a[i,j]``
    - (x1,y1),(x2,y2)(x1,y1),(x2,y2)这一子矩阵中的所有数之和为：``S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]``
[原题链接](https://www.acwing.com/solution/content/2117/)
```c++
#include <iostream>

using namespace std;
const int N=1010;
int q[N][N],s[N][N];

int n,m,t;

int main(){
    cin>>n>>m>>t;
    
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            cin>>q[i][j];
            s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+q[i][j];
        }
           
   while(t--){
       int x1,y1,x2,y2;
       cin>>x1>>y1>>x2>>y2;
       
       cout<<s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];
       cout<<endl;
   }
           
   return 0;         
}
```
# 差分
类似于数学中的求导和积分，**差分可以看成前缀和的逆运算**

差分数组：
首先给定一个原数组a：``a[1], a[2], a[3],,,,,, a[n];``
然后我们构造一个数组b ： ``b[1] ,b[2] , b[3],,,,,, b[i];``
使得`` a[i] = b[1] + b[2 ]+ b[3] +,,,,,, + b[i]``
也就是说，a数组是b数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。换句话说，每一个a[i]都是b数组中从头开始的一段区间和。
考虑如何构造差分b数组？
最为直接的方法
如下：
    ``a[0 ]= 0;``
    ``b[1] = a[1] - a[0];``
    ``b[2] = a[2] - a[1];``
    ``b[3] =a [3] - a[2];``
    ........
    ``b[n] = a[n] - a[n-1];``
- 作用
给定区间``[l ,r ]``，让我们把a数组中的``[ l, r]``区间中的每一个数都加上c,即 ``a[l] + c , a[l+1] + c , a[l+2] + c ,,,,,, a[r] + c;``

暴力做法是for循环l到r区间，时间复杂度O(n)，如果我们需要对原数组执行m次这样的操作，时间复杂度就会变成O(n*m)。有没有更高效的做法吗? 考虑差分做法。
始终要记得，a数组是b数组的前缀和数组，比如对b数组的b[i]的修改，会影响到a数组中从a[i]及往后的每一个数。

首先让差分b数组中的 ``b[l] + c ,a数组变成 a[l] + c ,a[l+1] + c,,,,,, a[n] + c;``
然后我们打个补丁，``b[r+1] - c, a数组变成 a[r+1] - c,a[r+2] - c,,,,,,,a[n] - c;``
[![ftkXHU.png](https://z3.ax1x.com/2021/08/10/ftkXHU.png)](https://imgtu.com/i/ftkXHU)
因此我们得出**一维差分结论**：给a数组中的[ l, r]区间中的每一个数都加上c,只需对差分数组b做`` b[l] + = c, b[r+1] - = c。``时间复杂度为O(1), 大大提高了效率。
```c++ [原题链接](https://www.acwing.com/problem/content/description/799/)
//差分 时间复杂度 o(m)
#include<iostream>
using namespace std;
const int N = 1e5 + 10;
int a[N], b[N];
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        b[i] = a[i] - a[i - 1];      //构建差分数组
    }
    int l, r, c;
    while (m--)
    {
        scanf("%d%d%d", &l, &r, &c);
        b[l] += c;     //将序列中[l, r]之间的每个数都加上c
        b[r + 1] -= c;
    }
    for (int i = 1; i <= n; i++)
    {
        a[i] = b[i] + a[i - 1];    //前缀和运算
        printf("%d ", a[i]);
    }
    return 0;
}

```
## 差分矩阵
[大佬题解](https://www.acwing.com/solution/content/27325/)
[原题链接](https://www.acwing.com/solution/content/2137/)
```c++
#include <iostream>

using namespace std;
const int N =1e3+10;
int n,m,q;
int a[N][N],b[N][N];

void insert(int x1,int y1,int x2,int y2,int c){//二维差分矩阵的插入
    b[x1][y1]+=c;
    b[x2+1][y1]-=c;
    b[x1][y2+1]-=c;
    b[x2+1][y2+1]+=c;
}

int main(){
    cin>>n>>m>>q;
    
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            insert(i,j,i,j,a[i][j]);//初始化差分矩阵，和插入二维矩阵类似，想象成1*1矩阵
        }
    }
    while(q--){
        int x1,y1,x2,y2,c;
        cin>>x1>>y1>>x2>>y2>>c;
        insert(x1,y1,x2,y2,c);
    }
    
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];//二维矩阵求前缀和
            cout<<b[i][j]<<' ';
        }
        cout<<endl;
    }
}
```
# 位运算
1. 
[![flgz6I.png](https://z3.ax1x.com/2021/08/08/flgz6I.png)](https://imgtu.com/i/flgz6I)
    - ``n>>k`` //右移
    - ``X&1`` 看个位是几

2. lowbit(X) ：返回x的最后一位1的位置
[![fJmn1A.png](https://z3.ax1x.com/2021/08/10/fJmn1A.png)](https://imgtu.com/i/fJmn1A)
lowbit(1010)返回值为10
- 作用：统计x中1的个数
[原题链接]（https://www.acwing.com/problem/content/description/25/）
```C++
class Solution {
public:
    int NumberOf1(int n) {
        int t=0;
        while(n){
            n-=n&-n;//每次减去n的最后一位1
            t++;
        }
        return t;
    }
};
```
3. 
x=1010
原码：000001010 x
反码：111110101 !x
补码：111110110 -x

# 离散化
[![fJYlB4.png](https://z3.ax1x.com/2021/08/10/fJYlB4.png)](https://imgtu.com/i/fJYlB4)
- 值域很大但是值很少
- 为什么要离散化呢，因为存储的下标实在太大了，如果直接开这么大的数组，根本不现实，第二个原因，本文是数轴，要是采用下标的话，可能存在负值，所以也不能。
- 离散化的本质，是映射，将间隔很大的点，映射到相邻的数组元素中。减少对空间的需求，也减少计算量。
其实映射最大的难点是前后的映射关系，如何能够将不连续的点映射到连续的数组的下标。此处的解决办法就是开辟额外的数组存放原来的数组下标，或者说下标标志，本文是原来上的数轴上的非连续点的横坐标。
首先要明确find函数的功能，输入一个离散数组的位置（映射前的位置）x返回连续数组的位置+1（映射后的位置+1）。+1的目的是为了求区间和时少一步下标为0的判断。
```C++
vector<int> alls;
sort(alls.begin(),alls.end());
alls.erase(unique(alls.begin(),alls.end()),alls.end());
//二分找出x对应的离散化的值
int find(int x){//从左至右第一个大于等于x的值
    int l=0,r=all.size()-1;
    while(l<r){
        int mid =l+r>>1;
        if(alls[mid]>=x) r=mid;
        else l=mid+1;
    }
    return r+1;//映射到1.2.3...n。为什么返回r + 1,这是变相的让映射后的数组从1开始。此处描述映射后的数组下标对应的数值用的是a数组。
}
```

- [原题链接](https://www.acwing.com/solution/content/3998/)
- 分析一下y总的代码。
主要分为5大步：
1.``读输入。将每次读入的x c push_back()到add中，将每次读入的位置x push_back()到alls中，将每次读入的l r push_back()到query中。``
2.排序、去重。
3.通过遍历add，完成在离散化的数组映射到的a数组中进行加上c的操作（用到find函数）。
4.初始化s数组。
5.通过遍历query，完成求区间[l,r]的和。
```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;

const int N = 300010;

int n, m;
int a[N], s[N];

vector<int> alls;//首先要明确alls中存放的是位置而不是值，也就是存放的是x而不是c。
vector<PII> add, query;

int find(int x)
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}


int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ )
    {
        int x, c;
        cin >> x >> c;
        add.push_back({x, c});

        alls.push_back(x);
    }

    for (int i = 0; i < m; i ++ )
    {
        int l, r;
        cin >> l >> r;
        query.push_back({l, r});

        alls.push_back(l);//求前缀和就需要下标l r，如果不加入l r到alls中的话，第5步中遍历时query就没有办法通过输入的l r去访问a或者s。因为find函数就是输入映射前的下标，返回在alls中的下标+1。
        alls.push_back(r);
    }

    // 去重
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(),alls.end()), alls.end());

    // 处理插入
    for (auto item : add)
    {
        int x = find(item.first);
        a[x] += item.second;
    }

    // 预处理前缀和
    for (int i = 1; i <= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];//因为映射从1开始到all.size()

    // 处理询问
    for (auto item : query)
    {
        int l = find(item.first), r = find(item.second);
        cout << s[r] - s[l - 1] << endl;
    }

    return 0;
}

```
- unique函数的实现(双指针)
```C++
vector<int>::iterator unique(vector<int> &a)
{
    int j = 0;
    for (int i = 0; i < a.size(); i ++ )
        if (!i || a[i] != a[i - 1])
            a[j ++ ] = a[i];
    // a[0] ~ a[j - 1] 所有a中不重复的数

    return a.begin() + j;
}
```
