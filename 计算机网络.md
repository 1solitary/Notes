# ping 的原理
## ip协议的助手-- ICMP协议
ping是基于ICMP协议工作的，所以要明白ping的工作，首先要熟悉ICMP协议。
***

### ICMP的概念
Internet Control Message Protocol-互联网控制报文协议

网络包在复杂的网络传输环境里，常常会遇到各种问题。当遇到问题的时候，总不能死个不明不白，没头没脑的作风不是计算机网络的风格。所以需要传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。
***
### ICMP的功能
ICMP的功能包括：确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因和改善网络设置等。

在IP通信中，如果某个IP包因为某种原因未能达到目标地址，那么这个具体的原因将由ICMP负责通知。

[![ROOk5T.png](https://z3.ax1x.com/2021/07/08/ROOk5T.png)](https://imgtu.com/i/ROOk5T)
主机A向主机B发送了数据包，由于某种原因，途中的路由器2未能发现主机B的存在，这时路由器2就会向主机A发送一个ICMP目标不可达数据包，说明发往主机B的包未能成功。

ICMP的通知消息会使用IP进行发送。

因此，从路由器2返回的ICMP包会按照往常的路由控制先经过路由器1再转发给主机A

收到该ICMP包的主机A则分解ICMP的首部和数据域以后得知具体发生问题的原因。
***
### ICMP包头格式
icmp报文是封装在ip包里面，它工作在网络层，是ip协议的助手。
![icmp包头格式](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcZiaMXRx5FarzuAMKmf0Cj29gb37HdxOjFprAJ1zycOxZdHEbz4tafArtrZFAibw90Dn1BJmgaG5eg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
ICMP包头的类型字段，大致可以分为两大类：
- 一类是用于诊断的查询信息，也就是**查询报文类型**
- 一类是通知出错原因的错误信息，也就是**差错报文类型**
[![WkQ3H1.png](https://z3.ax1x.com/2021/07/13/WkQ3H1.png)](https://imgtu.com/i/WkQ3H1)

#### 差错报文类型
- 目标不可达消息 —— 类型 为 3
IP路由器无法将IP数据包发给目标地址时，会给发送端主机返回一个目标不可达的ICMP消息，并在这个消息显示不可达的具体原因，原因记录在ICMP包头的代码字段。
> 常见目标不可达类型的代码
[![WA8Q9P.png](https://z3.ax1x.com/2021/07/13/WA8Q9P.png)](https://imgtu.com/i/WA8Q9P)
***
a. 网络不可达代码为 0
外卖版本：

小林第一次送外卖时，小区里只有 A 和 B 区两栋楼，但送餐地址写的是 C 区楼，小林表示头上很多问号，压根就没这个地方。

正常版本：

IP 地址是分为网络号和主机号的，所以当路由器中的路由器表匹配不到接收方 IP 的网络号，就通过 ICMP 协议以网络不可达（Network Unreachable）的原因告知主机。

自从不再有网络分类以后，网络不可达也渐渐不再使用了。
***
b. 主机不可达代码为 1
外卖版本：

小林第二次送外卖时，这次小区有 5 层楼高的 C 区楼了，找到地方了，但送餐地址写的是 C 区楼 601 号房 ，说明找不到这个房间。

正常版本：

当路由表中没有该主机的信息，或者该主机没有连接到网络，那么会通过 ICMP 协议以主机不可达（Host Unreachable）的原因告知主机。
***
c. 协议不可达代码为 2
外卖版本：

小林第三次送外卖时，这次小区有 C 区楼，也有 601 号房，找到地方了，也找到房间了，但是一开门人家是外国人说的是英语，我说的是中文！语言不通，外卖送达失败~

正常版本：

当主机使用 TCP 协议访问对端主机时，能找到对端的主机了，可是对端主机的防火墙已经禁止 TCP 协议访问，那么会通过 ICMP 协议以协议不可达的原因告知主机。
***
d. 端口不可达代码为 3
外卖版本：

小林第四次送外卖时，这次小区有 C 区楼，也有 601 号房，找到地方了，也找到房间了，房间里的人也是说中文的人了，但是人家说他要的不是外卖，而是快递。。。

正常版本：

当主机访问对端主机 8080 端口时，这次能找到对端主机了，防火墙也没有限制，可是发现对端主机没有进程监听 8080 端口，那么会通过 ICMP 协议以端口不可达的原因告知主机。
***
e. 需要进行分片但设置了不分片位代码为 4
外卖版本：

小林第五次送外卖时，这次是个吃播博主了 100 份外卖，但是吃播博主要求一次性要把全部外卖送达，小林的一台电动车装不下呀，这样就没办法送达了。

正常版本：

发送端主机发送 IP 数据报时，将 IP 首部的分片禁止标志位设置为1。根据这个标志位，途中的路由器遇到超过 MTU 大小的数据包时，不会进行分片，而是直接抛弃。

随后，通过一个 ICMP 的不可达消息类型，代码为 4 的报文，告知发送端主机。
***
- 原点抑制消息 —— 类型 4
在使用低速广域线路的情况下，连接WAN的路由器可能会遇到网络拥堵的问题。
ICMP原点抑制消息的目的就是为了缓和这种拥堵情况。
当路由器向低俗线路发送数据时，其发送队列的缓存变为0而无法发送出去时，可以向IP包的源地址发送一个ICMP原点抑制消息。
收到这个消息的主机借此了解整个线路的某一处发生了拥堵的情况，从而增大ip包的传输间隔，减少了网络拥堵的情况。
然而，由于这种ICMP可能会引起不公平的网络通信，一般不被使用。
***
- 重定向消息 —— 类型 5
如果路由器发现发送端主机使用了不是最优的路径发送数据，那么它会返回一个ICMP重定向消息给这个主机。
在这个消息包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下，路由器会通过这样的ICMP消息告知给发送端，让它下次发送给另一个路由器。
好比，小林本可以过条马路就能到的地方，但小林不知道，所以绕了一圈才到，后面小林知道后，下次小林就不会那么傻再绕一圈了。
***
- 超时消息 —— 类型 11
ip包中TTL字段的值，经过路由器就会减1，直到减到0时该ip包会被丢弃。
此时，ip路由器将会发送一个ICMP超时信息给发送端主机，并通知该包已被丢弃。
设置ip包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免ip包无休止地在网络上被转发。
[![WEUtoD.png](https://z3.ax1x.com/2021/07/13/WEUtoD.png)](https://imgtu.com/i/WEUtoD)  
此外，有时可以用TTL控制包的到达范围，例如设置一个较小的TTL值。          
***


#### 查询报文类型
> 回送消息--类型0和类型8

回送消息用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功达到对端的一种消息，ping命令就是利用这个消息实现的。
[![Wkl8MQ.png](https://z3.ax1x.com/2021/07/13/Wkl8MQ.png)](https://imgtu.com/i/Wkl8MQ)
可以向对端主机发送**回送请求**的消息（ICMP Echo Request Message，类型 8），也可以接收对端主机发回来的**回送应答**消息（ICMP Echo Reply Message，类型 0）。


#### ICMP回送请求和回送应答报文
[![WklTLd.png](https://z3.ax1x.com/2021/07/13/WklTLd.png)](https://imgtu.com/i/WklTLd)
相比原生的ICMP，这里多了两个字段
- 标识符：用以区分是哪个应用程序发ICMP包，比如用进程``PID``作为标识符
- 序号：序列号从0开始，每发送一次新的回送请求就会加1，可以用来确认网络包是否有丢失。
在**选项数据**中，``ping``还会存放发送请求的时间值，来计算往返时间，说明路程的长短。
***
## ping —— 查询报文类型的使用
同个子网下的主机A和主机B，主机A执行ping主机B后，我们来看看其间发送了什么？
[![WEUHTU.png](https://z3.ax1x.com/2021/07/13/WEUHTU.png)](https://imgtu.com/i/WEUHTU)

ping命令执行的时候，源主机首先会构建一个ICMP回送请求消息数据包。
ICMP数据包内包含多个字段，最重要的是两个：
- 第一个是类型，对于回送请求消息而言该字段为0
- 另外一个是序号，主要用于区分连续ping的时候发出的多个数据包。
每发出一个请求数据包，序号会自动加1.为了能够计算往返时间RTT，它会在报文的数据部分插入发送时间。

[![WE0r9g.png](https://z3.ax1x.com/2021/07/13/WE0r9g.png)](https://imgtu.com/i/WE0r9g)

每发出一个请求数据包，序号会自动加1。为了能够计算往返时间``RTT``，它会在报文的数据部分插入发送时间。

然后，由icmp协议将这个数据包连同地址一起交给ip层。
> 主机A的ip层数据包
[![WVFgQ1.png](https://z3.ax1x.com/2021/07/14/WVFgQ1.png)](https://imgtu.com/i/WVFgQ1)

接下来，需要加入Mac头。如果在本地ARP映射表中查找出ip地址192.168.1.2 所对应的 MAC 地址。如果在本地ARP映射表中查找出IP地址192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送``ARP``协议查询MAC地址，获取MAC地址后，由数据链路层构建一个数据帧，目的地址是ip层传过来的MAC地址，源地址是本机的MAC地址；还要附加上一些控制消息，根据以太网的介质访问规则，将它们传送出去。
> 主机A的MAC层数据包
[![WV3gl6.png](https://z3.ax1x.com/2021/07/14/WV3gl6.png)](https://imgtu.com/i/WV3gl6)

主机B收到这个数据帧后，先检查它的目的MAC地址，并和本机的MAC地址对比，如符合则接收，否则就丢弃。
接收后检查数据帧，将ip数据包从帧从提取出来，交给本机的IP层。同样，ip层检查后将有用的信息提取后交给ICMP协议。

主机B会构建一个**ICMP回送响应消息**数据包，回送响应数据包的类型字段为0，序号为接收到的请求数据包中的序号，然后再发送出去给主机A。
在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。

此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。
针对上面发生的事情，总结成了如下图
[![WVUEB6.png](https://z3.ax1x.com/2021/07/14/WVUEB6.png)](https://imgtu.com/i/WVUEB6)

说了这么多，可以看出 ping 这个程序是使用了**ICMP 里面的 ECHO REQUEST（类型为 8 ） 和 ECHO REPLY （类型为 0）。**

## traceroute —— 差错报文类型的使用
有一款充分利用 ICMP 差错报文类型的应用叫做 traceroute（在UNIX、MacOS中是这个命令，而在Windows中对等的命令叫做 tracert ）。
### traceroute 作用一

traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。

traceroute 的参数指向某个目的 IP 地址：

traceroute 192.168.1.100
这个作用是如何工作的呢？

它的原理就是利用 IP 包的生存期限 从 1 开始按照顺序递增的同时发送 UDP 包，强制接收 ICMP 超时消息的一种方法。

比如，将 TTL 设置 为 1，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是时间超时。

接下来将 TTL 设置为 2，第一个路由器过了，遇到第二个路由器也牺牲了，也同意返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。

这样的过程，traceroute 就可以拿到了所有的路由器 IP。

当然有的路由器根本就不会返回这个 ICMP，所以对于有的公网地址，是看不到中间经过的路由的。

发送方如何知道发出的 UDP 包是否到达了目的主机呢？

traceroute 在发送 UDP 包时，会填入一个不可能的端口号值作为 UDP 目标端口号（大于 3000 ）。当目的主机，收到 UDP 包后，会返回 ICMP 差错报文消息，但这个差错报文消息的类型「端口不可达」。

所以，当差错报文类型是端口不可达时，说明发送方发出的 UDP 包到达了目的主机。
***
### traceroute 作用二

traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。

这么做是为了什么？

这样做的目的是为了路径MTU发现。

因为有的时候我们并不知道路由器的 MTU 大小，以太网的数据链路上的 MTU 通常是 1500 字节，但是非以太网的 MTU 值就不一样了，所以我们要知道 MTU 的大小，从而控制发送的包大小。

[![WVwlv9.png](https://z3.ax1x.com/2021/07/14/WVwlv9.png)](https://imgtu.com/i/WVwlv9)
MTU 路径发现（UDP的情况下）
它的工作原理如下：

首先在发送端主机发送 IP 数据报时，将 IP 包首部的分片禁止标志位设置为 1。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。

随后，通过一个 ICMP 的不可达消息将数据链路上 MTU 的值一起给发送主机，不可达消息的类型为「需要进行分片但设置了不分片位」。

发送主机端每次收到 ICMP 差错报文时就减少包的大小，以此来定位一个合适的 MTU 值，以便能到达目标主机。


# ip数据报的首部格式

![ip数据报](https://gitee.com/BloothOfYouth/image/raw/master//20201020153846.png)
- 一个 IP 数据报由首部和数据两部分组成。
- 首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。
- 在首部的固定部分的后面是一些可选字段，其长度是可变的。
- 图中的每一行都由32个比特（也就是4个字节）构成，每个小格子称为字段或者域，每个字段或某些字段的组合用来表达IP协议的相关功能。
## 各字段的作用
- 版本：占4比特，表示ip协议的版本。
通信双方使用ip协议的版本必须一致，目前广泛使用的协议版本为ipv4。
- 首部长度：占4比特，表示ip数据报首部的长度，该字段的取值以4字节为单位。
最小十进制取值为4，表示ip数据报首部只有20字节固定部分；``一个单位为4字节，4*5=20字节。``
最大十进制取值为15，表示ip数据报首部包含20字节固定部分和最大40字节可变部分。
- 可选字段：长度从1一个字节到40个字节不等，用来支持排错、测量及安全等措施。可选字段增加了ip数据报的功能，但这同时也使得ip数据报的首部长度成为可变的，这就增加了每一个路由器处理ip数据报的开销，实际可选字段很少被使用。
- 填充字段。确保首部长度为4字节的整数倍，使用全0进行填充。
> **IP数据报的首部长度一定是4字节的整数倍**
因为首部中的可选字段的长度从1个字节到40个字节不等，那么，当20字节的固定部分加上1到40个字节长度不等的可变部分，会造成首部长度不是4字节整数倍时，就用取值为全0的填充字段填充相应个字节，以确保IP数据报的首部长度是4字节的整数倍
- 区分服务：占8比特，用来获取更好的服务。
利用该字段的不同数值可提供不同等级的服务质量。只有在使用区分服务时，该字段才起作用，一般情况下都不适用该字段。
- 总长度：占16比特，表示ip数据报的总长度（首部+数据长度）
最大取值为十进制的65535，以字节为单位。
![ip数据报分片](https://gitee.com/BloothOfYouth/image/raw/master//20201020153903.png)
[![WFN4OO.png](https://z3.ax1x.com/2021/07/12/WFN4OO.png)](https://imgtu.com/i/WFN4OO)
![数据报分片](https://gitee.com/BloothOfYouth/image/raw/master//20201020153909.png)
- 生存时间TTL：占8比特，最大生存周期为255秒。作用是防止ip数据报在网络中永久兜圈。
路由器转发数据报时，将ip数据报首部中的该字段的值减去在本路由器上所耗费的时间，若不为0就转发，否则就丢弃。
- 协议：占8比特。数据报的数据部分是何种协议数据单元。
[![WknRmt.png](https://z3.ax1x.com/2021/07/13/WknRmt.png)](https://imgtu.com/i/WknRmt)
- 首部校验和[![WkK4zQ.png](https://z3.ax1x.com/2021/07/13/WkK4zQ.png)](https://imgtu.com/i/WkK4zQ)
- 源地址和目的ip地址：各占32比特，用来填写发送该ip数据报的源主机的ip地址和接受该ip数据报的目的主机的ip地址。

# 当键入网址后，到网页显示，其间发生了什么
> 简单网络拓扑模型
[![WVsc9K.png](https://z3.ax1x.com/2021/07/14/WVsc9K.png)](https://imgtu.com/i/WVsc9K)

## 孤独的小弟-- HTTP
首先浏览器做的第一步工作就是要对``URL``进行解析，从而处理发送给``WEB``服务器的请求消息。

> URL解析
[![WVyQgO.png](https://z3.ax1x.com/2021/07/14/WVyQgO.png)](https://imgtu.com/i/WVyQgO)
所以图中的长长的 URL 实际上是请求服务器里的文件资源。
当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是`` /index.html ``或者 ``/default.html ``这些文件，这样就不会发生混乱了。

对``URL``进行解析之后，浏览器确定类WEB服务器和文件名，接下来就是根据这些信息来生成HTTP请求消息了。
> HTTP的消息格式
 [![WeiBvR.png](https://z3.ax1x.com/2021/07/14/WeiBvR.png)](https://imgtu.com/i/WeiBvR)

## 真实地址查询--DNS
通过浏览器解析URL并生成HTTP消息后，需要委托操作系统将消息发送给``WEB``服务器。

但在发送之前，还有一项工作需要完成，那就是**查询服务器域名对应的IP地址**，因为委托操作系统发送消息时，必须提供通信对象的IP地址。

比如我们打电话的时候，必须要知道对方的电话号码，但由于但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。

所以，有一种服务器就专门保存了``WEB``服务器域名和``IP``的对应关系，它就是``DNS``服务器。

### 域名的层级关系
DNS的域名都是用句点来分割的，比如``www.server.com``,这里的句点代表了不同层次之间的界限。

在域名中，越靠右的位置表示其层级越高。
根域是在最顶层，它的下一层就是 com 顶级域，再下面是 server.com。
所以域名的层级关系类似一个树状结构。
- 根 DNS 服务器
- 顶级域 DNS 服务器（com）
- 权威 DNS 服务器（server.com）
> DNS树状结构
[![WeAw8g.png](https://z3.ax1x.com/2021/07/14/WeAw8g.png)](https://imgtu.com/i/WeAw8g)

根域的DNS服务器信息保存在互联网中所有的DNS服务器中。
这样一来，任何DNS服务器就都可以找到并访问根域DNS服务器。
因此，客户端只要能够找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标DNS服务器。

### 域名解析的工作流程

1. 客户端首先会发出一个DNS请求，问www.server.com的IP是啥，并发给本地DNS服务器。
2. 本地域名服务器收到客户端的请求后，如果在缓存的表格里能找到www.server.com，则它直接返回ip地址。如果没有，本地DNS会去问它的根域名服务器询问ip地址。
根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
3. 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”

4. 本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com  的 IP 地址吗？”

5. 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。

6. 本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。

7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。

8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

DNS域名解析的过程蛮有意思的，整个过程就和我们日常过程中找人问路的过程类似，**只指路不带路**。

> 数据包表示：“DNS 老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢?”

## 指南好帮手--协议栈
通过DNS获取IP后，就可以把HTTP的传输工作交给操作系统的协议栈。

协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。
[![WeGIQ1.png](https://z3.ax1x.com/2021/07/14/WeGIQ1.png)](https://imgtu.com/i/WeGIQ1)

应用程序（浏览器）通过调用Socket库，来委托协议栈工作，协议栈的上半部分有两块，分别是负责收发数据的TCP和UDP协议，它们会接受应用层的委托执行收发数据的操作。

协议栈的下面一半是用IP协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由ip负责的。

此外 IP 中还包括 ICMP 协议和 ARP 协议。
- ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。
- ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

ip下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接受操作。

## 可靠传输--TCP
HTTP是基于TCP协议传输的，所以在这里了解下TCP协议。

> TCP包头格式
[![WeOPkn.png](https://z3.ax1x.com/2021/07/15/WeOPkn.png)](https://imgtu.com/i/WeOPkn)
首先，**源端口号**和**目标端口号**是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。

接下来是包的**序号**，这个是为了解决包乱序的问题。

接下来是**确认号**，目的是确认发出去对方是否有收到，如果没有收到就应该重新发送，直到送达，这个是为了解决不丢包的问题。

接下来还有一些**状态位**。例如``SYN``是发起一个连接，``ACK``是回复，``RST``是重新连接，``FIN``是结束连接等，TCP是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

还有一个更重要的是**窗口大小**。TCP要做**流量控制**，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。

TCP还会做**拥塞控制**，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。

> TCP传输数据之前，要先三次握手建立连接。
这个所谓的连接，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。
[![WexPDU.png](https://z3.ax1x.com/2021/07/15/WexPDU.png)](https://imgtu.com/i/WexPDU)
注意``seq和ack``的数值变化

- 一开始，客户端和服务端都处于``CLOSED``状态。先是服务端主动监听某个端口，处于``LISTEN``状态。
- 然后客户端主动发起连接``SYN``，之后处于``SYN-SENT``状态。
- 服务端收到发起的连接，返回``SYN``，并且``ACK``客户端的``SYN``，之后处于``SYN-RCVD``状态。
- 客户端收到服务器端发送的``SYN``和``ACK``之后，发送``ACK``的``ACK``,之后处于``ESTABLISHED``状态，因为它一收一发成功了。
- 服务端收到``ACK``的``ACK``之后，处于``ESTABLISHED``状态，因为它也一收一发了。

所以三次握手的目的是**保证双方都有发送和接收的能力。**

> TCP的连接状态
TCP 的连接状态查看，在 Linux 可以通过 ``netstat -napt ``命令查看。
